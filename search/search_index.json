{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-test provides tools to facilitate unit testing of your\n\nzend-mvc\n applications.\n\n\nPHPUnit is the only library supported currently.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-test provides tools to facilitate unit testing of your zend-mvc  applications.  PHPUnit is the only library supported currently.",
            "title": "Introduction"
        },
        {
            "location": "/phpunit/",
            "text": "Unit testing with PHPUnit\n\n\nZend\\Test\\PHPUnit\n provides an abstract \nTestCase\n for zend-mvc applications\nthat contains assertions for testing against a variety of responsibilities.\nProbably the easiest way to understand what it can do is to see an example.\n\n\nThe following is a simple test case for an \nIndexController\n to verify things\nsuch as the final HTTP status code, and the discovered controller and action\nnames:\n\n\nnamespace ApplicationTest\\Controller;\n\nuse Zend\\Test\\PHPUnit\\Controller\\AbstractHttpControllerTestCase;\n\nclass IndexControllerTest extends AbstractHttpControllerTestCase\n{\n    public function setUp()\n    {\n        $this->setApplicationConfig(\n            include '/path/to/application/config/test/application.config.php'\n        );\n        parent::setUp();\n    }\n\n    public function testIndexActionCanBeAccessed()\n    {\n        $this->dispatch('/');\n        $this->assertResponseStatusCode(200);\n\n        $this->assertModuleName('application');\n        $this->assertControllerName('application_index');\n        $this->assertControllerClass('IndexController');\n        $this->assertMatchedRouteName('home');\n    }\n}\n\n\n\nThe setup of the test case should define the application config. You can use\nseveral configuration files to test module dependencies or your current\napplication config.\n\n\nSetup your TestCase\n\n\nAs noted in the previous example, all MVC test cases should extend\n\nAbstractHttpControllerTestCase\n.  This class in turn extends\n\nPHPUnit_Framework_TestCase\n, and gives you all the structure and assertions\nyou'd expect from PHPUnit, as well as some scaffolding and assertions specific\nto zend-mvc.\n\n\nIn order to test your MVC application, you will need to setup the application\nconfiguration. Use the \nsetApplicationConfig()\n method to do this:\n\n\npublic function setUp()\n{\n    $this->setApplicationConfig(\n        include '/path/to/application/config/test/application.config.php'\n    );\n    parent::setUp();\n}\n\n\n\nOnce the application is set up, you can write your tests. To help debug tests,\nyou can activate the flag \ntraceError\n to throw MVC exceptions during test\nexecution:\n\n\nnamespace ApplicationTest\\Controller;\n\nuse Zend\\Test\\PHPUnit\\Controller\\AbstractHttpControllerTestCase;\n\nclass IndexControllerTest extends AbstractHttpControllerTestCase\n{\n    protected $traceError = true;\n}\n\n\n\nTesting your Controllers and MVC Applications\n\n\nOnce you have your application config in place, you can begin testing. Testing\nis basically as you would expect in an PHPUnit test suite, with a few minor\ndifferences.\n\n\nFirst, you will need to dispatch a URL to test, using the \ndispatch\n method of\nthe TestCase:\n\n\npublic function testIndexAction()\n{\n    $this->dispatch('/');\n}\n\n\n\nThere will be times, however, that you need to provide extra information: query\nstring arguments, POST, variables, cookies, etc.  You can populate the request\nwith that information:\n\n\npublic function testIndexAction()\n{\n    $this->getRequest()\n        ->setMethod('POST')\n        ->setPost(new Parameters(['argument' => 'value']));\n    $this->dispatch('/');\n}\n\n\n\nYou can populate query string arguments or POST variables directly with the\n\ndispatch\n method:\n\n\npublic function testIndexAction()\n{\n    $this->dispatch('/', 'POST', ['argument' => 'value']);\n}\n\n\n\nQuery string arguments can be provided in the URL you dispatch:\n\n\npublic function testIndexAction()\n{\n    $this->dispatch('/tests?foo=bar&baz=foo');\n}\n\n\n\nNow that the request is made, it's time to start \nmaking assertions\n against it.",
            "title": "Unit testing with PHPUnit"
        },
        {
            "location": "/phpunit/#unit-testing-with-phpunit",
            "text": "Zend\\Test\\PHPUnit  provides an abstract  TestCase  for zend-mvc applications\nthat contains assertions for testing against a variety of responsibilities.\nProbably the easiest way to understand what it can do is to see an example.  The following is a simple test case for an  IndexController  to verify things\nsuch as the final HTTP status code, and the discovered controller and action\nnames:  namespace ApplicationTest\\Controller;\n\nuse Zend\\Test\\PHPUnit\\Controller\\AbstractHttpControllerTestCase;\n\nclass IndexControllerTest extends AbstractHttpControllerTestCase\n{\n    public function setUp()\n    {\n        $this->setApplicationConfig(\n            include '/path/to/application/config/test/application.config.php'\n        );\n        parent::setUp();\n    }\n\n    public function testIndexActionCanBeAccessed()\n    {\n        $this->dispatch('/');\n        $this->assertResponseStatusCode(200);\n\n        $this->assertModuleName('application');\n        $this->assertControllerName('application_index');\n        $this->assertControllerClass('IndexController');\n        $this->assertMatchedRouteName('home');\n    }\n}  The setup of the test case should define the application config. You can use\nseveral configuration files to test module dependencies or your current\napplication config.",
            "title": "Unit testing with PHPUnit"
        },
        {
            "location": "/phpunit/#setup-your-testcase",
            "text": "As noted in the previous example, all MVC test cases should extend AbstractHttpControllerTestCase .  This class in turn extends PHPUnit_Framework_TestCase , and gives you all the structure and assertions\nyou'd expect from PHPUnit, as well as some scaffolding and assertions specific\nto zend-mvc.  In order to test your MVC application, you will need to setup the application\nconfiguration. Use the  setApplicationConfig()  method to do this:  public function setUp()\n{\n    $this->setApplicationConfig(\n        include '/path/to/application/config/test/application.config.php'\n    );\n    parent::setUp();\n}  Once the application is set up, you can write your tests. To help debug tests,\nyou can activate the flag  traceError  to throw MVC exceptions during test\nexecution:  namespace ApplicationTest\\Controller;\n\nuse Zend\\Test\\PHPUnit\\Controller\\AbstractHttpControllerTestCase;\n\nclass IndexControllerTest extends AbstractHttpControllerTestCase\n{\n    protected $traceError = true;\n}",
            "title": "Setup your TestCase"
        },
        {
            "location": "/phpunit/#testing-your-controllers-and-mvc-applications",
            "text": "Once you have your application config in place, you can begin testing. Testing\nis basically as you would expect in an PHPUnit test suite, with a few minor\ndifferences.  First, you will need to dispatch a URL to test, using the  dispatch  method of\nthe TestCase:  public function testIndexAction()\n{\n    $this->dispatch('/');\n}  There will be times, however, that you need to provide extra information: query\nstring arguments, POST, variables, cookies, etc.  You can populate the request\nwith that information:  public function testIndexAction()\n{\n    $this->getRequest()\n        ->setMethod('POST')\n        ->setPost(new Parameters(['argument' => 'value']));\n    $this->dispatch('/');\n}  You can populate query string arguments or POST variables directly with the dispatch  method:  public function testIndexAction()\n{\n    $this->dispatch('/', 'POST', ['argument' => 'value']);\n}  Query string arguments can be provided in the URL you dispatch:  public function testIndexAction()\n{\n    $this->dispatch('/tests?foo=bar&baz=foo');\n}  Now that the request is made, it's time to start  making assertions  against it.",
            "title": "Testing your Controllers and MVC Applications"
        },
        {
            "location": "/assertions/",
            "text": "Assertions\n\n\nAssertions are at the heart of unit testing; you use them to verify that the\nresults are what you expect. To this end, \nZend\\Test\\PHPUnit\\AbstractControllerTestCase\n\nprovides a number of assertions to make testing your MVC apps and controllers\nsimpler.\n\n\nRequest Assertions\n\n\nIt's often useful to assert against the last run action, controller, and module;\nadditionally, you may want to assert against the route that was matched. The\nfollowing assertions can help you in this regard:\n\n\n\n\nassertModulesLoaded(array $modules)\n: Assert that the given modules were\n  loaded by the application.\n\n\nassertModuleName($module)\n: Assert that the given module was used in the last\n  dispatched action.\n\n\nassertControllerName($controller)\n: Assert that the given controller\n  identifier was selected in the last dispatched action.\n\n\nassertControllerClass($controller)\n: Assert that the given controller class\n  was selected in the last dispatched action.\n\n\nassertActionName($action)\n: Assert that the given action was last dispatched.\n\n\nassertMatchedRouteName($route)\n: Assert that the given named route was\n  matched by the router.\n\n\n\n\nEach also has a 'Not' variant for negative assertions.\n\n\nCSS Selector Assertions\n\n\nCSS selectors are an easy way to verify that certain artifacts are present in\nthe response content.  They also make it trivial to ensure that items necessary\nfor JavaScript UIs and/or AJAX integration will be present; most JS toolkits\nprovide some mechanism for manipulating DOM elements based on CSS selectors, so\nthe syntax would be the same.\n\n\nThis functionality is provided via \nZend\\Dom\\Query\n,\nand integrated into a set of 'Query' assertions. Each of these assertions takes\nas their first argument a CSS selector, with optionally additional arguments\nand/or an error message, based on the assertion type. You can find the rules for\nwriting the CSS selectors in the zend-dom \nTheory of Operation\n\nchapter. Query assertions include:\n\n\n\n\nassertQuery($path)\n: assert that one or more DOM elements matching the given\n  CSS selector are present.\n\n\nassertQueryContentContains($path, $match)\n: assert that one or more DOM\n  elements matching the given CSS selector are present, and that at least one\n  contains the content provided in \n$match\n.\n\n\nassertQueryContentRegex($path, $pattern)\n: assert that one or more DOM\n  elements matching the given CSS selector are present, and that at least one\n  matches the regular expression provided in \n$pattern\n.\n\n\nassertQueryCount($path, $count)\n: assert that there are exactly \n$count\n DOM\n  elements matching the given CSS selector present.\n\n\nassertQueryCountMin($path, $count)\n: assert that there are at least \n$count\n\n  DOM elements matching the given CSS selector present.\n\n\nassertQueryCountMax($path, $count)\n: assert that there are no more than\n  \n$count\n DOM elements matching the given CSS selector present.\n\n\n\n\nAll queries above also allow an optional \n$message\n argument; when provided,\nthat message will be used when displaying assertion failures.\n\n\nAdditionally, each of the above has a 'Not' variant that provides a negative\nassertion: \nassertNotQuery()\n, \nassertNotQueryContentContains()\n,\n\nassertNotQueryContentRegex()\n, and \nassertNotQueryCount()\n. (Note that the min\nand max counts do not have these variants, for what should be obvious reasons.)\n\n\nXPath Assertions\n\n\nSome developers are more familiar with XPath than with CSS selectors, and thus\nXPath variants of all the Query assertions are also provided. These are:\n\n\n\n\nassertXpathQuery($path)\n: assert against the given XPath selection\n\n\nassertNotXpathQuery($path)\n: assert against the given XPath selection;\n  negative assertions\n\n\nassertXpathQueryCount($path, $count)\n: assert against XPath selection; should\n  contain exact number of nodes\n\n\nassertNotXpathQueryCount($path, $count)\n: assert against DOM/XPath selection;\n  should not contain exact number of nodes\n\n\nassertXpathQueryCountMin($path, $count)\n: assert against XPath selection;\n  should contain at least this number of nodes\n\n\nassertXpathQueryCountMax($path, $count)\n: assert against XPath selection;\n  should contain no more than this number of nodes\n\n\nassertXpathQueryContentContains($path, $match)\n: assert against XPath\n  selection; node should contain content\n\n\nassertNotXpathQueryContentContains($path, $match)\n: assert against XPath\n selection; node should not contain content\n\n\nassertXpathQueryContentRegex($path, $pattern)\n: assert against XPath\n  selection; node should match content\n\n\nassertNotXpathQueryContentRegex($path, $pattern)\n: assert against XPath\n  selection; node should not match content\n\n\n\n\nRedirect Assertions\n\n\nOften an action will redirect. Instead of following the redirect,\n\nZend\\Test\\PHPUnit\\ControllerTestCase\n allows you to test for redirects with a\nhandful of assertions.\n\n\n\n\nassertRedirect()\n: assert simply that a redirect has occurred.\n\n\nassertRedirectTo($url)\n: assert that a redirect has occurred, and that the\n  value of the \nLocation\n header is the \n$url\n provided.\n\n\nassertRedirectRegex($pattern)\n: assert that a redirect has occurred, and that\n  the value of the \nLocation\n header matches the regular expression provided by\n  \n$pattern\n.\n\n\n\n\nEach also has a 'Not' variant for negative assertions.\n\n\nResponse Header Assertions\n\n\nIn addition to checking for redirect headers, you will often need to check for specific HTTP\nresponse codes and headers; for instance, to determine whether an action results in a 404 or 500\nresponse, or to ensure that JSON responses contain the appropriate \nContent-Type\n header. The\nfollowing assertions are available.\n\n\n\n\nassertResponseStatusCode($code)\n: assert that the response resulted in the\n  given HTTP response code.\n\n\nassertResponseHeader($header)\n: assert that the response contains the given\n  header.\n\n\nassertResponseHeaderContains($header, $match)\n: assert that the response\n  contains the given header and that its content contains the given string.\n\n\nassertResponseHeaderRegex($header, $pattern)\n: assert that the response\n  contains the given header and that its content matches the given regex.\n\n\nassertHasResponseHeader($header)\n: assert that the response header exists.\n\n\n\n\nAdditionally, each of the above assertions have a 'Not' variant for negative assertions.\n\n\n\n\nassertResponseReasonPhrase($phrase)\n: assert the the response has the given\n  reason phrase\n\n\n\n\nOther Assertions\n\n\nApplication Exceptions\n\n\n\n\nassertApplicationException($type, $message = null)\n: assert the given \n  application exception type and message.\n\n\n\n\nTemplate name\n\n\n\n\nassertTemplateName($templateName)\n: assert that a template was used somewhere\n  in the view model tree.\n\n\nassertNotTemplateName($templateName)\n: assert that a template was not used\n  somewhere in the view model tree.",
            "title": "Assertions"
        },
        {
            "location": "/assertions/#assertions",
            "text": "Assertions are at the heart of unit testing; you use them to verify that the\nresults are what you expect. To this end,  Zend\\Test\\PHPUnit\\AbstractControllerTestCase \nprovides a number of assertions to make testing your MVC apps and controllers\nsimpler.",
            "title": "Assertions"
        },
        {
            "location": "/assertions/#request-assertions",
            "text": "It's often useful to assert against the last run action, controller, and module;\nadditionally, you may want to assert against the route that was matched. The\nfollowing assertions can help you in this regard:   assertModulesLoaded(array $modules) : Assert that the given modules were\n  loaded by the application.  assertModuleName($module) : Assert that the given module was used in the last\n  dispatched action.  assertControllerName($controller) : Assert that the given controller\n  identifier was selected in the last dispatched action.  assertControllerClass($controller) : Assert that the given controller class\n  was selected in the last dispatched action.  assertActionName($action) : Assert that the given action was last dispatched.  assertMatchedRouteName($route) : Assert that the given named route was\n  matched by the router.   Each also has a 'Not' variant for negative assertions.",
            "title": "Request Assertions"
        },
        {
            "location": "/assertions/#css-selector-assertions",
            "text": "CSS selectors are an easy way to verify that certain artifacts are present in\nthe response content.  They also make it trivial to ensure that items necessary\nfor JavaScript UIs and/or AJAX integration will be present; most JS toolkits\nprovide some mechanism for manipulating DOM elements based on CSS selectors, so\nthe syntax would be the same.  This functionality is provided via  Zend\\Dom\\Query ,\nand integrated into a set of 'Query' assertions. Each of these assertions takes\nas their first argument a CSS selector, with optionally additional arguments\nand/or an error message, based on the assertion type. You can find the rules for\nwriting the CSS selectors in the zend-dom  Theory of Operation \nchapter. Query assertions include:   assertQuery($path) : assert that one or more DOM elements matching the given\n  CSS selector are present.  assertQueryContentContains($path, $match) : assert that one or more DOM\n  elements matching the given CSS selector are present, and that at least one\n  contains the content provided in  $match .  assertQueryContentRegex($path, $pattern) : assert that one or more DOM\n  elements matching the given CSS selector are present, and that at least one\n  matches the regular expression provided in  $pattern .  assertQueryCount($path, $count) : assert that there are exactly  $count  DOM\n  elements matching the given CSS selector present.  assertQueryCountMin($path, $count) : assert that there are at least  $count \n  DOM elements matching the given CSS selector present.  assertQueryCountMax($path, $count) : assert that there are no more than\n   $count  DOM elements matching the given CSS selector present.   All queries above also allow an optional  $message  argument; when provided,\nthat message will be used when displaying assertion failures.  Additionally, each of the above has a 'Not' variant that provides a negative\nassertion:  assertNotQuery() ,  assertNotQueryContentContains() , assertNotQueryContentRegex() , and  assertNotQueryCount() . (Note that the min\nand max counts do not have these variants, for what should be obvious reasons.)",
            "title": "CSS Selector Assertions"
        },
        {
            "location": "/assertions/#xpath-assertions",
            "text": "Some developers are more familiar with XPath than with CSS selectors, and thus\nXPath variants of all the Query assertions are also provided. These are:   assertXpathQuery($path) : assert against the given XPath selection  assertNotXpathQuery($path) : assert against the given XPath selection;\n  negative assertions  assertXpathQueryCount($path, $count) : assert against XPath selection; should\n  contain exact number of nodes  assertNotXpathQueryCount($path, $count) : assert against DOM/XPath selection;\n  should not contain exact number of nodes  assertXpathQueryCountMin($path, $count) : assert against XPath selection;\n  should contain at least this number of nodes  assertXpathQueryCountMax($path, $count) : assert against XPath selection;\n  should contain no more than this number of nodes  assertXpathQueryContentContains($path, $match) : assert against XPath\n  selection; node should contain content  assertNotXpathQueryContentContains($path, $match) : assert against XPath\n selection; node should not contain content  assertXpathQueryContentRegex($path, $pattern) : assert against XPath\n  selection; node should match content  assertNotXpathQueryContentRegex($path, $pattern) : assert against XPath\n  selection; node should not match content",
            "title": "XPath Assertions"
        },
        {
            "location": "/assertions/#redirect-assertions",
            "text": "Often an action will redirect. Instead of following the redirect, Zend\\Test\\PHPUnit\\ControllerTestCase  allows you to test for redirects with a\nhandful of assertions.   assertRedirect() : assert simply that a redirect has occurred.  assertRedirectTo($url) : assert that a redirect has occurred, and that the\n  value of the  Location  header is the  $url  provided.  assertRedirectRegex($pattern) : assert that a redirect has occurred, and that\n  the value of the  Location  header matches the regular expression provided by\n   $pattern .   Each also has a 'Not' variant for negative assertions.",
            "title": "Redirect Assertions"
        },
        {
            "location": "/assertions/#response-header-assertions",
            "text": "In addition to checking for redirect headers, you will often need to check for specific HTTP\nresponse codes and headers; for instance, to determine whether an action results in a 404 or 500\nresponse, or to ensure that JSON responses contain the appropriate  Content-Type  header. The\nfollowing assertions are available.   assertResponseStatusCode($code) : assert that the response resulted in the\n  given HTTP response code.  assertResponseHeader($header) : assert that the response contains the given\n  header.  assertResponseHeaderContains($header, $match) : assert that the response\n  contains the given header and that its content contains the given string.  assertResponseHeaderRegex($header, $pattern) : assert that the response\n  contains the given header and that its content matches the given regex.  assertHasResponseHeader($header) : assert that the response header exists.   Additionally, each of the above assertions have a 'Not' variant for negative assertions.   assertResponseReasonPhrase($phrase) : assert the the response has the given\n  reason phrase",
            "title": "Response Header Assertions"
        },
        {
            "location": "/assertions/#other-assertions",
            "text": "",
            "title": "Other Assertions"
        },
        {
            "location": "/assertions/#application-exceptions",
            "text": "assertApplicationException($type, $message = null) : assert the given \n  application exception type and message.",
            "title": "Application Exceptions"
        },
        {
            "location": "/assertions/#template-name",
            "text": "assertTemplateName($templateName) : assert that a template was used somewhere\n  in the view model tree.  assertNotTemplateName($templateName) : assert that a template was not used\n  somewhere in the view model tree.",
            "title": "Template name"
        }
    ]
}